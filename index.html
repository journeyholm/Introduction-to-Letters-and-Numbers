<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Toddler's Letter & Number Adventure</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f0f9ff;
            --primary-color: #3b82f6;
            --secondary-color: #fbbf24;
            --correct-color: #22c55e;
            --incorrect-color: #ef4444;
            --pink-color: #ec4899;
            --purple-color: #8b5cf6;
            --teal-color: #14b8a6; /* New color for the counting button */
            --orange-color: #f97316; /* New color for shapes button */
            --text-color: #1e293b;
            --font-main: 'Fredoka One', cursive;
            --font-ui: 'Inter', sans-serif;
        }

        /* General Body Styles */
        body {
            font-family: var(--font-ui);
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Game Container */
#game-container {
            width: 100%;
            max-width: 600px;
            height: 100vh;      /* Full viewport height */
            height: 100dvh;     /* dynamic viewport height for mobile browsers */
            background: linear-gradient(to bottom, #f0f9ff, #e0f2fe); /* Subtle polish */
            display: flex;
            flex-direction: column;
            overflow: hidden;   /* KILL THE SCROLL */
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        /* Particle Canvas for effects */
        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 300;
        }

        /* Header UI */
        .game-header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid #e2e8f0;
            z-index: 10;
        }

        .stat-item {
            display: flex;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary-color);
            background-color: #eff6ff;
            padding: 8px 12px;
            border-radius: 9999px;
        }

        .stat-item span {
            margin-left: 8px;
        }
        
        .avatar-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #avatar-display {
            position: relative;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            background-color: var(--secondary-color);
            border: 3px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 9999px;
        }
        #avatar-display svg {
            width: 70%;
            height: 70%;
        }
        .avatar-accessory {
            position: absolute;
            font-size: 1.5rem;
            top: -15px;
            left: 5px;
            transform: rotate(-15deg);
        }
        #avatar-name-display {
            font-family: var(--font-main);
            font-size: 0.8rem;
            margin-top: 2px;
            color: var(--text-color);
            background-color: #f1f5f9;
            padding: 1px 6px;
            border-radius: 6px;
            min-height: 1.2em;
        }


        /* Main Game Area */
/* --- SMART GAME LAYOUT --- */
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Start from top */
            align-items: center;
            padding: 15px;
            width: 100%;
            height: 100%;
            overflow-y: auto; /* Safety scroll enabled */
            box-sizing: border-box;
        }

        /* Specific fix for "In Order" Grid spacing */
        #in-order-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); /* Smart sizing */
            gap: 10px;
            width: 100%;
            max-width: 800px;
            margin-bottom: 20px;
            padding-bottom: 40px; /* Space for scrolling thumb */
        }
        
        /* Make In-Order buttons easier to hit */
        .in-order-item {
            font-family: var(--font-main);
            font-size: 1.8rem; /* Bigger text */
            height: 60px;      /* Bigger hit target */
            border-radius: 12px;
            background-color: white;
            box-shadow: 0 4px 0 #cbd5e1; /* 3D feel */
            border: 1px solid #94a3b8;
        }
        .in-order-item:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* Options Grid */
 /* Responsive Grid */
/* --- GIANT BUTTON GRID --- */
        #options-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2x2 Layout */
            gap: 12px;
            width: 100%;
            height: 100%; /* Fill the rest of the screen! */
            max-height: 50vh; /* Cap it so it doesn't look weird on tall phones */
            margin-top: auto; /* Push to bottom if there's space */
        }

        .option-button {
            font-family: var(--font-main);
            font-size: 4rem; /* Big text */
            width: 100%;
            height: 100%; /* Stretch to fill the grid cell */
            border: none;
            border-radius: 20px;
            cursor: pointer;
            color: white;
            position: relative;
            box-shadow: 0 6px 0 rgba(0,0,0,0.2); /* Juicy 3D effect */
            transition: transform 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900; /* Extra bold */
            -webkit-text-stroke: 3px rgba(0,0,0,0.2); /* Thick outline */
            text-shadow: 4px 4px 0px rgba(0,0,0,0.15); /* Deep shadow */
            
            /* Force the specific Yellow button to be readable */
        }

        .option-button:active {
            transform: translateY(6px);
            box-shadow: none;
        }
        
        /* Make shape SVGs fit perfectly inside the big buttons */
        .option-button svg {
            width: 60%;
            height: 60%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        /* Animation for correct/incorrect */
        .option-button.correct-glow { animation: glow-correct 1s ease; }
        .option-button.shake-incorrect, .in-order-item.shake-incorrect { animation: shake 0.5s ease; }

        @keyframes glow-correct {
            0%, 100% { box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
            50% { box-shadow: 0 0 30px 10px var(--correct-color); transform: scale(1.05); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-10px); }
            40%, 80% { transform: translateX(10px); }
        }
        
        /* New styles for Counting Game Mode */
/* --- SMART DISPLAY AREA --- */
        #item-display-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 5px;
            width: 100%;
            /* REMOVED min-height: 110px <-- This was the culprit! */
            transition: all 0.3s ease;
        }

        /* MAGICAL CSS: If empty, take up ZERO space */
        #item-display-area:empty {
            display: none;
            margin: 0;
            padding: 0;
            height: 0;
        }
        
        /* When active (Counting Game), give it style */
/* High Quality Counting Grid */
        #item-display-area:not(:empty) {
            background-color: rgba(255,255,255,0.8);
            border: 3px dashed var(--primary-color);
            border-radius: 25px;
            padding: 15px;
            margin-bottom: 20px;
            flex-shrink: 0;
            
            /* The 10-Frame Layout */
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 items per row */
            gap: 10px;
            justify-items: center;
            max-width: 350px; /* Keep it compact */
        }

        .counting-item {
            font-size: 3rem; /* BIG emojis */
            filter: drop-shadow(0 4px 2px rgba(0,0,0,0.1));
            animation: pop-in 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes pop-in {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* In-Order Game Mode Styles */
        #in-order-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px; /* Reduced from 10px */
            width: 100%;
            padding: 5px; /* Reduced from 10px */
        }
        
        .in-order-item {
            font-family: var(--font-main);
            font-size: 1.5rem; /* Reduced from 1.8rem */
            height: 45px; /* Reduced from 50px */
            border: 2px solid #d1d5db;
            border-radius: 10px;
            cursor: pointer;
            color: var(--text-color);
            background-color: #f9fafb;
            transition: all 0.2s ease-in-out;
        }
        
        .in-order-item.completed {
            background-color: var(--correct-color);
            color: white;
            border-color: var(--correct-color);
            opacity: 0.7;
        }
        
/* --- HORIZONTAL TICKER TAPE (Fixes the cut-off!) --- */
        #sequence-display-container {
            display: flex;
            flex-wrap: nowrap;     /* Force one single line */
            overflow-x: auto;      /* Enable sideways scrolling */
            align-items: center;
            gap: 8px;
            width: 100%;
            height: 70px;          /* Fixed nice height */
            flex-shrink: 0;        /* Never shrink this */
            padding: 0 10px;
            background-color: #e0e7ff;
            border-radius: 15px;
            margin-bottom: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
            -webkit-overflow-scrolling: touch; /* Smooth swipe on iPad */
        }

        .sequence-item {
            flex: 0 0 40px;        /* Fixed width - won't squish */
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-family: var(--font-main);
            font-size: 1.2rem;
            color: #cbd5e1;        /* Faint grey when empty */
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .sequence-item.filled {
            background-color: var(--secondary-color);
            border-color: #d97706;
            color: white; /* Make the letter pop */
            font-weight: bold;
            transform: scale(1.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .sequence-item.filled {
            background-color: var(--secondary-color);
            border-color: #f59e0b;
            color: var(--text-color);
            transform: scale(1.1);
            transition: all 0.3s ease;
        }

        /* Bottom Navigation */
        .game-nav {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .nav-button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 2.5rem;
            color: #94a3b8;
            transition: color 0.2s, transform 0.2s;
        }
        .nav-button.active { color: var(--primary-color); }
        .nav-button:hover { color: var(--primary-color); transform: translateY(-5px); }
        
        /* Modals */
.modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            z-index: 200; /* CHANGED FROM 50 TO 200 */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal.visible { opacity: 1; pointer-events: auto; }

        .modal-content {
            background: white;
            padding: 15px; /* Reduced from 20px */
            border-radius: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }
        .modal-title {
            font-family: var(--font-main);
            font-size: 2rem; /* Reduced from 2.5rem */
            margin-bottom: 10px; /* Reduced from 20px */
            color: var(--primary-color);
        }
        .close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2rem;
            cursor: pointer;
            color: var(--text-color);
        }
        
        /* Badge Display */
        #badge-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 15px;
        }
        .badge { font-size: 3rem; opacity: 0.3; filter: grayscale(1); transition: all 0.3s; }
        .badge.unlocked { opacity: 1; filter: none; transform: scale(1.1); }
        .badge-tooltip { font-size: 0.8rem; margin-top: -5px; color: #64748b; }

        /* Game Mode Selection Menu */
        #menu-container .game-mode-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 15px;
            border: none;
            font-family: var(--font-main);
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #menu-container .game-mode-button:active { transform: scale(0.95); }
        
/* --- IMPROVED SHOP STYLES --- */
        #shop-container {
            padding-bottom: 20px;
            width: 100%;
            height: 100%;
            overflow-y: auto; 
            -webkit-overflow-scrolling: touch;
        }

        .shop-coin-display {
            font-family: var(--font-main);
            font-size: 2rem;
            color: #d97706;
            background-color: #fffbeb;
            padding: 8px 20px;
            border-radius: 99px;
            margin: 10px auto 15px;
            border: 3px solid #fcd34d;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .shop-category-title {
            font-family: var(--font-main);
            font-size: 1.5rem;
            color: #334155;
            margin-bottom: 5px;
            padding-left: 15px;
            text-shadow: 1px 1px 0 white;
        }

        .shop-shelf {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            padding: 10px 15px 25px 15px; /* Extra bottom padding for tags */
            scrollbar-width: none;
        }
        .shop-shelf::-webkit-scrollbar { display: none; }

        /* The Product Card */
        .shop-item {
            flex: 0 0 100px;
            height: 120px;
            border-radius: 15px;
            background: white;
            border: 3px solid #cbd5e1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 0 #94a3b8; /* Chunky 3D bottom */
            transition: transform 0.1s;
            cursor: pointer;
        }
        .shop-item:active { 
            transform: translateY(4px); 
            box-shadow: 0 0 0 #94a3b8; 
        }

        /* Special Style for Color Swatches */
        .shop-item.color-item {
            border-radius: 50%; /* Make colors circular! */
            width: 100px; /* Force circle */
        }
        
        /* State: EQUIPPED (Wearing it now) */
        .shop-item.selected {
            border-color: var(--correct-color);
            box-shadow: 0 0 0 4px #bbf7d0, 0 8px 0 #16a34a; /* Double glow + 3D */
            background: #f0fdf4;
            transform: translateY(-5px);
            z-index: 10;
        }

        .shop-item svg { width: 65%; height: 65%; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1)); }

        /* Badges */
        .shop-tag {
            position: absolute;
            bottom: -12px;
            font-family: var(--font-main);
            font-size: 0.85rem;
            padding: 4px 10px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            white-space: nowrap;
        }
        
        .tag-price { background: #64748b; }
        .tag-owned { background: var(--primary-color); }
        .tag-equipped { background: var(--correct-color); transform: scale(1.1); border: 2px solid white;}
        
        .can-afford .tag-price { background: var(--correct-color); animation: bounce-tag 1s infinite; }
        .cannot-afford .tag-price { background: var(--incorrect-color); opacity: 0.8; }
        
        @keyframes bounce-tag {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Animation for "Not Enough Money" */
        .shake-no-money { animation: shake 0.4s ease-in-out; }
        
/* --- NEW COOL AVATAR BUILDER --- */
        #avatar-builder-modal .modal-content {
            background: #f8fafc;
            padding: 0; /* Full width stage */
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            border-radius: 0;
            display: flex;
            flex-direction: column;
        }

        #avatar-builder-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        /* 1. The "Stage" - Bigger and centered */
        #avatar-preview-area {
            width: 100%;
            height: 35vh; /* Takes up top 35% of screen */
            background: radial-gradient(circle at center, #ffffff 0%, #e2e8f0 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 5px solid white;
            box-shadow: 0 10px 20px rgba(0,0,0,0.05);
            position: relative;
            flex-shrink: 0;
            z-index: 10;
        }
        
        #avatar-preview-area svg {
            width: 180px; /* Much bigger avatar */
            height: 180px;
            filter: drop-shadow(0 10px 10px rgba(0,0,0,0.2)); /* 3D Shadow effect */
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 2. The Name Input - Floating on the stage */
        #avatar-name-input {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            background: rgba(255,255,255,0.8);
            border: 2px solid #cbd5e1;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            font-size: 1.5rem;
            z-index: 20;
        }

        /* 3. The "Shelves" - Swipe left/right! */
        #builder-scroll-area {
            flex-grow: 1;
            overflow-y: auto; /* Fixes the "can't see bottom" bug */
            padding: 20px;
            background: #f1f5f9;
        }

        .builder-category {
            margin-bottom: 25px;
        }

        .builder-category-title {
            font-family: var(--font-main);
            font-size: 1.2rem;
            color: #64748b;
            margin-bottom: 10px;
            margin-left: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .builder-options {
            display: flex;
            gap: 15px;
            overflow-x: auto; /* This enables horizontal swiping */
            padding: 5px 5px 15px 5px; /* Space for bounce shadow */
            -webkit-overflow-scrolling: touch; /* Smooth scroll on iPad */
            scrollbar-width: none; /* Hide scrollbar for neatness */
        }
        .builder-options::-webkit-scrollbar { display: none; }

        .builder-option {
            flex: 0 0 70px; /* Fixed big size */
            height: 70px;
            border: 3px solid white;
            border-radius: 18px;
            background: white;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .builder-option.selected {
            border-color: var(--primary-color);
            transform: scale(1.15) translateY(-5px); /* Pop up effect */
            box-shadow: 0 10px 20px rgba(59, 130, 246, 0.3);
            z-index: 5;
        }

        /* 4. The Finish Button - Fixed at bottom */
        #builder-finish-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            font-size: 1.5rem;
            background: var(--correct-color);
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
            z-index: 50;
            border-radius: 99px;
        }


        /* Custom Confirm Modal */
        #confirm-modal .modal-content { max-width: 300px; }
        #confirm-text { font-size: 1.2rem; margin-bottom: 20px; }
        #confirm-buttons { display: flex; justify-content: center; gap: 15px;}
        .confirm-btn {
            font-family: var(--font-main);
            font-size: 1.5rem;
            padding: 10px 30px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            color: white;
        }
        #confirm-yes { background-color: var(--correct-color); }
        #confirm-no { background-color: var(--incorrect-color); }


        /* Hide screens */
        .screen { display: none; }
        .screen.active { display: flex; }
/* Hint Animation */
        @keyframes hint-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(59, 130, 246, 0.5); border-color: var(--primary-color); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }
        .hint-active {
            animation: hint-pulse 1.5s infinite;
            z-index: 10;
        }
        /* --- AVATAR SCREEN UPGRADES --- */
        @keyframes avatar-breathe {
            0%, 100% { transform: scale(1) translateY(0); }
            50% { transform: scale(1.03) translateY(-5px); }
        }
        
        #avatar-preview-area svg {
            /* Add breathing animation to the existing SVG style */
            animation: avatar-breathe 3s ease-in-out infinite; 
        }

#btn-randomize {
            position: absolute;
            top: 20px;         /* Top of the preview stage */
            left: 20px;        /* Left side */
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
            background: #8b5cf6; /* Purple */
            font-size: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 50;
            transition: transform 0.2s;
        }
        #btn-randomize:active { transform: scale(0.9) rotate(360deg); } /* Spin when clicked! */

        #btn-randomize {
            left: 20px;
            background: #8b5cf6; /* Purple */
        }
        
        #builder-finish-btn {
            /* Overwrite old style to match new icons */
            right: 20px;
            padding: 0;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            font-size: 2.5rem;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="particle-canvas"></canvas>

        <header class="game-header">
            <div class="avatar-wrapper">
                 <div id="avatar-display" class="stat-item"></div>
            </div>
            <div id="stat-coins" class="stat-item">
                <span>üí∞</span><span id="coins-count">0</span>
            </div>
            <div id="stat-streak" class="stat-item">
                <span>üî•</span><span id="streak-count">0</span>
            </div>
        </header>
        
        <main id="game-screen" class="main-content screen active"></main>
        <main id="in-order-screen" class="main-content screen"></main>

<nav class="game-nav">
            <button id="nav-home" class="nav-button" title="Home">üè†</button>
            <button id="nav-badges" class="nav-button" title="My Badges">üèÜ</button>
            <button id="nav-skip" class="nav-button" title="Skip / Next">‚è≠Ô∏è</button>
            <button id="nav-shop" class="nav-button" title="Shop">üõçÔ∏è</button>
        </nav>

        <div id="menu-modal" class="modal visible"></div>
        <div id="badges-modal" class="modal"></div>
        <div id="shop-modal" class="modal"></div>
        
        <!-- New Modals -->
        <div id="avatar-builder-modal" class="modal"></div>
        <div id="confirm-modal" class="modal"></div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const el = (id) => document.getElementById(id);
        const elAll = (selector) => document.querySelectorAll(selector);

        // --- DOM ELEMENTS ---
        const gameContainer = document.getElementById('game-container');
        const coinsCountEl = document.getElementById('coins-count');
        const streakCountEl = document.getElementById('streak-count');
        const avatarDisplayEl = document.getElementById('avatar-display');
        const avatarNameDisplayEl = document.getElementById('avatar-name-display');

        // Screens
        const gameScreen = document.getElementById('game-screen');
        const inOrderScreen = document.getElementById('in-order-screen');

        // Modals
        const menuModal = document.getElementById('menu-modal');
        const badgesModal = document.getElementById('badges-modal');
        const shopModal = document.getElementById('shop-modal');
        const avatarBuilderModal = document.getElementById('avatar-builder-modal');
        const confirmModal = document.getElementById('confirm-modal');
        
        // Navigation
        const navHomeBtn = document.getElementById('nav-home');
        const navBadgesBtn = document.getElementById('nav-badges');
        const navShopBtn = document.getElementById('nav-shop');

        // --- GAME STATE ---
        let state = {
            coins: 0,
            streak: 0,
            gameMode: 'letters',
            unlockedBadges: [],
            currentItem: null,
            options: [],
            inOrderIndex: 0,
            inOrderSequence: [],
            inOrderDisplaySequence: [],
            avatarChosen: false,
            avatarName: 'BUD',
            selectedAvatar: {
                head: 'shape1',
                eyes: 'eyes1',
                mouth: 'mouth1',
                color: '#3b82f6',
            },
unlockedAvatarParts: {
                // Free Shapes: Circle, Square, Triangle, Bear, Bunny, Dog
                head: ['shape1', 'shape2', 'shape3', 'shape8', 'shape9', 'shape10'], 
                // Free Eyes: Dots, Cartoon, Sleepy, X-Eyes, Happy
                eyes: ['eyes1', 'eyes2', 'eyes3', 'eyes4', 'eyes6', 'eyes8'], 
                // Free Mouths: Smile, Open, Straight, Zigzag, Snout, Cat
                mouth: ['mouth1', 'mouth2', 'mouth3', 'mouth4', 'mouth6', 'mouth7'], 
                color: ['#3b82f6', '#ef4444', '#22c55e', '#fbbf24'] 
            },
            selectedAccessory: 'none',
            unlockedAccessories: ['none'],
            unlockedStickers: [],
            unlockedItems: { backgrounds: ['default'], cursors: ['default'] },
            selectedItems: { background: 'default', cursor: 'default' },
        };

        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        const ALPHABET_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz'.split(''); // New: for matching
        const NUMBERS = Array.from({length: 21}, (_, i) => String(i)); // 0-20
        const COUNTING_ITEMS = ['üçé', 'üçå', '‚≠ê', 'üöó', 'üê∂', 'üéà', 'üßÅ', 'ü¶Ü', '‚òÄÔ∏è', 'üê∏'];

        // --- NEW DATA for Shapes & Colors ---
        const COLORS = [
            { name: 'red', hex: '#ef4444' },
            { name: 'blue', hex: '#3b82f6' },
            { name: 'yellow', hex: '#fbbf24' },
            { name: 'green', hex: '#22c55e' },
            { name: 'purple', hex: '#8b5cf6' },
            { name: 'pink', hex: '#ec4899' },
            { name: 'orange', hex: '#f97316' }
        ];

        // --- NEW: Congratulatory phrases ---
        const CORRECT_PHRASES = [
            "Yay!", "Nice!", "Good!", "Great job!", "Well done!", "Correct!", 
            "Excellent!", "Amazing!", "Super!", "Fantastic!"
        ];

        const SHAPES = [
            { name: 'circle', svg: '<circle cx="50" cy="50" r="40"/>' },
            { name: 'square', svg: '<rect x="10" y="10" width="80" height="80" rx="5"/>' },
            { name: 'triangle', svg: '<polygon points="50,10 90,90 10,90"/>' },
            { name: 'star', svg: '<polygon points="50,5 61.8,38.2 98.8,38.2 68.5,59.8 79.3,95 50,72.8 20.7,95 31.5,59.8 1.2,38.2 38.2,38.2"/>' },
            { name: 'heart', svg: '<path d="M50 30 C30 10, 10 30, 25 50 L50 80 L75 50 C90 30, 70 10, 50 30 Z"/>' }
        ];
        
        const BADGES = {
            first_correct: { icon: '‚úÖ', title: 'First Correct!', description: 'Answer your first question right.' },
            streak_5: { icon: 'üî•', title: 'On Fire!', description: 'Get a 5-answer streak.' },
            streak_10: { icon: 'üöÄ', title: 'Rocket Streak!', description: 'Get a 10-answer streak.' },
            coins_50: { icon: 'üí∞', title: 'Coin Collector', description: 'Earn 50 coins.' },
            coins_250: { icon: 'üè¶', title: 'Coin Bank', description: 'Earn 250 coins.' },
            shop_explorer: { icon: 'üó∫Ô∏è', title: 'Explorer', description: 'Visit the shop for the first time.' },
            first_purchase: { icon: 'üí∏', title: 'First Purchase!', description: 'Buy your first item.' },
            all_letters_found: { icon: 'üî§', title: 'Alphabet Master', description: 'Find all letters once.' },
            all_numbers_found: { icon: 'üî¢', title: 'Number Wizard', description: 'Find all numbers once.' },
            in_order_letters: { icon: 'üé∂', title: 'ABC Singer', description: 'Complete letters in order.' },
            in_order_numbers: { icon: 'üíØ', title: 'Count to 20!', description: 'Complete numbers in order.' },
        };
        let foundLetters = new Set();
        let foundNumbers = new Set();
        
        // --- AVATAR & SHOP DATA ---
const AVATAR_PARTS = {
            head: {
                // Shapes
                shape1: '<path d="M50 95C25.1472 95 5 74.8528 5 50C5 25.1472 25.1472 5 50 5C74.8528 5 95 25.1472 95 50C95 74.8528 74.8528 95 50 95Z"/>', // Circle
                shape2: '<path d="M5 5H95V95H5V5Z"/>', // Square
                shape3: '<path d="M50 15 L95 85 L5 85 Z"/>', // Triangle
                shape4: '<path d="M50 5 L61.8 38.2 L98.8 38.2 L68.5 59.8 L79.3 95 L50 72.8 L20.7 95 L31.5 59.8 L1.2 38.2 L38.2 38.2 Z"/>', // Star
                shape5: '<path d="M50 30 C30 10, 10 30, 25 50 L50 80 L75 50 C90 30, 70 10, 50 30 Z"/>', // Heart
                // Animals & Fun
                shape8: '<circle cx="20" cy="25" r="15"/><circle cx="80" cy="25" r="15"/><circle cx="50" cy="50" r="45"/>', // Bear/Mouse
                shape9: '<ellipse cx="30" cy="20" rx="10" ry="30" transform="rotate(-20 30 20)"/><ellipse cx="70" cy="20" rx="10" ry="30" transform="rotate(20 70 20)"/><circle cx="50" cy="50" r="45"/>', // Bunny
                shape10: '<path d="M10 30 L30 80 L10 80 Z" /><path d="M90 30 L70 80 L90 80 Z" /><circle cx="50" cy="50" r="45"/>', // Dog
                shape11: '<path d="M50 5 L80 25 L80 85 L20 85 L20 25 Z"/><line x1="20" y1="45" x2="10" y2="45" stroke-width="3"/><line x1="80" y1="45" x2="90" y2="45" stroke-width="3"/>', // Robot
                shape12: '<path d="M30 15 Q10 10 20 40 L50 30 L80 40 Q90 10 70 15 L50 30 Z" fill="currentColor"/><circle cx="50" cy="55" r="40"/>', // Monster
            },
            eyes: {
                eyes1: '<circle cx="35" cy="40" r="5"/><circle cx="65" cy="40" r="5"/>', // Dots
                eyes2: '<circle cx="35" cy="40" r="8" fill="white" stroke="black" stroke-width="2"/><circle cx="35" cy="40" r="3" fill="black"/><circle cx="65" cy="40" r="8" fill="white" stroke="black" stroke-width="2"/><circle cx="65" cy="40" r="3" fill="black"/>', // Cartoon
                eyes3: '<path d="M25 40H45"/><path d="M55 40H75"/>', // Closed
                eyes4: '<path d="M25 35 L35 45 L45 35" stroke-width="2"/><path d="M55 35 L65 45 L75 35" stroke-width="2"/>', // Sleeping V
                eyes5: '<circle cx="35" cy="40" r="10" fill="none" stroke="black" stroke-width="2"/><circle cx="65" cy="40" r="10" fill="none" stroke="black" stroke-width="2"/><line x1="45" y1="40" x2="55" y2="40" stroke-width="2"/>', // Glasses
                eyes6: '<path d="M30 35 L45 45 M45 35 L30 45" stroke-width="3"/><path d="M55 35 L70 45 M70 35 L55 45" stroke-width="3"/>', // X Eyes
                eyes7: '<circle cx="50" cy="40" r="12" fill="white" stroke="black"/><circle cx="50" cy="40" r="5" fill="black"/>', // Cyclops
                eyes8: '<path d="M25 35 Q35 25 45 35 T 65 35" stroke-width="2" fill="none"/><circle cx="35" cy="40" r="3"/><circle cx="65" cy="40" r="3"/>', // Happy Brows
            },
            mouth: {
                mouth1: '<path d="M35 70 Q50 85 65 70" stroke-width="4" stroke-linecap="round" fill="none"/>', // Smile
                mouth2: '<circle cx="50" cy="75" r="8" fill="black"/>', // Open O
                mouth3: '<path d="M35 75 H65" stroke-width="4" stroke-linecap="round"/>', // Straight
                mouth4: '<path d="M35 70 L45 80 L55 70 L65 80" stroke-width="3" fill="none"/>', // Zigzag
                mouth5: '<path d="M35 70 Q50 85 65 70" fill="white" stroke="black" stroke-width="2"/><path d="M40 70 L45 80 L50 70 M50 70 L55 80 L60 70"/>', // Vampire
                mouth6: '<ellipse cx="50" cy="70" rx="12" ry="8" fill="pink" stroke="black"/><circle cx="45" cy="70" r="2" fill="black"/><circle cx="55" cy="70" r="2" fill="black"/>', // Pig Snout
                mouth7: '<path d="M40 70 Q45 80 50 70 Q55 80 60 70" stroke-width="2" fill="none"/><line x1="30" y1="75" x2="10" y2="70"/><line x1="70" y1="75" x2="90" y2="70"/>', // Cat/Bunny
                mouth8: '<rect x="35" y="70" width="30" height="10" fill="none" stroke="black" stroke-width="2"/><line x1="45" y1="70" x2="45" y2="80"/><line x1="55" y1="70" x2="55" y2="80"/>', // Robot
            }
        };

const SHOP_DATA = {
            avatarParts: [
                // Colors (Cheap!)
                { id: 'color-#ec4899', name: 'Pink', cost: 10, type: 'color', value: '#ec4899' },
                { id: 'color-#f97316', name: 'Orange', cost: 10, type: 'color', value: '#f97316' },
                { id: 'color-#14b8a6', name: 'Teal', cost: 10, type: 'color', value: '#14b8a6' },
                { id: 'color-#8b5cf6', name: 'Purple', cost: 15, type: 'color', value: '#8b5cf6' },
                { id: 'color-#9ca3af', name: 'Grey', cost: 15, type: 'color', value: '#9ca3af' },

                // Premium Shapes
                { id: 'head-shape4', name: 'Star', cost: 25, type: 'head', value: 'shape4' },
                { id: 'head-shape5', name: 'Heart', cost: 25, type: 'head', value: 'shape5' },
                { id: 'head-shape11', name: 'Robot', cost: 40, type: 'head', value: 'shape11' },
                { id: 'head-shape12', name: 'Monster', cost: 40, type: 'head', value: 'shape12' },

                // Premium Eyes
                { id: 'eyes-eyes5', name: 'Glasses', cost: 20, type: 'eyes', value: 'eyes5' },
                { id: 'eyes-eyes7', name: 'Cyclops', cost: 30, type: 'eyes', value: 'eyes7' },

                // Premium Mouths
                { id: 'mouth-mouth5', name: 'Vampire', cost: 20, type: 'mouth', value: 'mouth5' },
                { id: 'mouth-mouth8', name: 'Robot', cost: 30, type: 'mouth', value: 'mouth8' },
            ],
            accessories: [
                { id: 'none', name: 'None', cost: 0, value: ''},
                { id: 'üëë', name: 'Crown', cost: 30, value: 'üëë' },
                { id: 'üòé', name: 'Glasses', cost: 20, value: 'üòé' },
                { id: 'ü•≥', name: 'Party Hat', cost: 15, value: 'ü•≥' },
                { id: 'üé©', name: 'Top Hat', cost: 40, value: 'üé©' },
                { id: 'üéÄ', name: 'Bow', cost: 15, value: 'üéÄ' }
            ],
            backgrounds: [
                { id: 'default', name: 'Default', cost: 0, value: 'white' },
                { id: 'sky', name: 'Sky', cost: 15, value: 'linear-gradient(to bottom, #87ceeb, #f0f9ff)' },
                { id: 'sunny', name: 'Sunny', cost: 25, value: 'linear-gradient(to bottom, #fde047, #facc15)' },
                { id: 'forest', name: 'Forest', cost: 30, value: 'linear-gradient(to bottom, #4ade80, #22c55e)' },
                { id: 'night', name: 'Night Sky', cost: 40, value: 'linear-gradient(to bottom, #0f172a, #334155)' },
                { id: 'candy', name: 'Candy', cost: 50, value: 'linear-gradient(45deg, #f9a8d4, #f472b6, #ec4899)' },
            ],
            cursors: [
                { id: 'default', name: 'Default', cost: 0, value: 'auto' },
                { id: '‚≠ê', name: 'Star', cost: 10, value: '‚≠ê' },
                { id: 'üíñ', name: 'Heart', cost: 10, value: 'üíñ' },
                { id: '‚ú®', name: 'Sparkle', cost: 20, value: '‚ú®' },
                { id: 'üöÄ', name: 'Rocket', cost: 30, value: 'üöÄ' },
            ],
            stickers: {
                first_correct: { icon: 'üåü', name: 'First Star!' },
                streak_5: { icon: '‚òÑÔ∏è', name: 'Comet!' },
                streak_10: { icon: 'üõ∏', name: 'UFO!' },
                coins_50: { icon: 'üíé', name: 'Gem!' },
                coins_250: { icon: 'üèõÔ∏è', name: 'Bank!' },
                shop_explorer: { icon: 'üß≠', name: 'Compass!' },
                first_purchase: { icon: 'üõçÔ∏è', name: 'Shopping Bag!' },
                all_letters_found: { icon: 'üìö', name: 'Bookworm!' },
                all_numbers_found: { icon: 'üí°', name: 'Bright Idea!' },
                in_order_letters: { icon: 'üé§', name: 'Super Singer!' },
                in_order_numbers: { icon: 'üèÜ', name: 'Winner!' },
            }
        };

        // --- SPEECH & SOUND ---
        const synth = window.speechSynthesis;
        let voices = [];
        function populateVoiceList() {
            voices = synth.getVoices().filter(voice => voice.lang.startsWith('en'));
        }
        
        populateVoiceList();
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = populateVoiceList;
        }

function speak(text, rate = 0.9, pitch = 1.2) {
            // 1. Stop previous sound
            if (synth.speaking) synth.cancel();

            const utterThis = new SpeechSynthesisUtterance(text);
            
            // 2. Keep alive in memory (Fixes the cut-off bug)
            window.activeSpeech = utterThis;

            // 3. PRIORITY: Find a clear FEMALE voice (They sound best for kids)
            // We look for Google Female, then iOS Samantha, then Windows Zira
            const preferredVoice = 
                voices.find(v => v.name.includes('Google') && v.name.includes('Female')) ||
                voices.find(v => v.name === 'Samantha') || 
                voices.find(v => v.name.includes('Zira')) ||
                voices.find(v => v.lang === 'en-US' && v.name.includes('Female')) ||
                voices.find(v => v.lang === 'en-US'); // Fallback

            if (preferredVoice) utterThis.voice = preferredVoice;

            // 4. Set Happy Teacher Settings
            utterThis.pitch = pitch; // 1.2 = Happy/Younger
            utterThis.rate = rate;   // 0.9 = Clear, not dragging

            synth.speak(utterThis);
        }

        // --- PARTICLE EFFECTS ---
        const canvas = document.getElementById('particle-canvas');
        let ctx = null;
        if (canvas.getContext) ctx = canvas.getContext('2d');
        let particles = [];
        
        function resizeCanvas() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        // Magic Finger Trail
// Magic Sand Trail
        function spawnTrail(x, y) {
            const colors = ['#ef4444', '#3b82f6', '#fbbf24', '#22c55e', '#ec4899', '#8b5cf6'];
            particles.push({
                x: x, y: y,
                text: '‚Ä¢', // A simple dot for "sand"
                color: colors[Math.floor(Math.random() * colors.length)], // Pick a random color
                size: Math.random() * 20 + 10, // Varied size
                vx: (Math.random() - 0.5) * 4, 
                vy: (Math.random() - 0.5) * 4,
                life: 100 // Start fully visible
            });
        }

        // Add touch/mouse listeners to the container
        gameContainer.addEventListener('mousemove', (e) => {
             // Get mouse position relative to canvas
             const rect = canvas.getBoundingClientRect();
             spawnTrail(e.clientX - rect.left, e.clientY - rect.top);
        });
        
        gameContainer.addEventListener('touchmove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Loop through all fingers touching the screen
            for (let i = 0; i < e.touches.length; i++) {
                spawnTrail(e.touches[i].clientX - rect.left, e.touches[i].clientY - rect.top);
            }
        }, {passive: true});

function createConfetti() {
            const count = 60;
            const emojis = ['‚≠ê', 'üéà', 'üíñ', 'üéâ', 'üßÅ', 'ü¶Ñ'];
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: canvas.width / 2, 
                    y: canvas.height / 2,
                    text: emojis[Math.floor(Math.random() * emojis.length)], // Pick an emoji
                    size: Math.random() * 30 + 15,
                    vx: Math.random() * 10 - 5, 
                    vy: Math.random() * -15 - 5,
                    life: 100,
                });
            }
        }

function animateParticles() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((p, index) => {
                p.vy += 0.4; // Gravity
                p.x += p.vx; 
                p.y += p.vy; 
                p.life--;
                
                if (p.life <= 0) particles.splice(index, 1);
                else {
                    ctx.font = `${p.size}px serif`;
                    // THE FIX: Use the particle's color (or black for default)
                    ctx.fillStyle = p.color || 'black';
                    ctx.globalAlpha = p.life / 100;
                    ctx.fillText(p.text, p.x, p.y);
                }
            });
            ctx.globalAlpha = 1;
            requestAnimationFrame(animateParticles);
        }

        // --- LOCAL STORAGE ---
        function saveProgress() {
            localStorage.setItem('toddlerGameProgress', JSON.stringify(state));
        }

        function loadProgress() {
            const progress = JSON.parse(localStorage.getItem('toddlerGameProgress'));
            if (progress) Object.assign(state, progress);
            applyShopItems();
            applyAvatar();
            updateUI();
        }
        
        // --- UI & TEMPLATE RENDERING ---
        function updateUI() {
            coinsCountEl.textContent = state.coins;
            streakCountEl.textContent = state.streak;
            if (avatarNameDisplayEl) {
                 avatarNameDisplayEl.textContent = state.avatarName;
            }
            renderAllTemplates();
        }

        function renderAllTemplates() {
            renderTemplate('menu-modal');
            renderTemplate('badges-modal');
            renderTemplate('shop-modal');
            renderTemplate('avatar-builder-modal');
            renderTemplate('confirm-modal');
        }

        function renderTemplate(templateId) {
            const el = document.getElementById(templateId);
            if (!el) return;
            
            let content = ''; // <-- Added declaration
            switch(templateId) { // <-- Added missing switch statement
                case 'game-screen': // <-- Added missing case
                    content = `<div id="prompt-container"><div id="prompt-speaker">üîä</div><p id="prompt-text">Find the letter...</p></div>
                        <!-- New display area for counting items -->
                        <div id="item-display-area"></div> 
                        <div id="options-grid"></div>`;
                    break;
                case 'in-order-screen':
                    content = `<div id="sequence-display-container"></div><p id="in-order-prompt" style="font-family: var(--font-main); font-size: 1.8rem; text-align: center; margin-bottom: 10px;">Click the letters in order!</p><div id="in-order-grid"></div>`;
                    break;
case 'menu-modal':
                    content = `<div id="menu-container" class="modal-content">
                        <h2 class="modal-title">Let's Learn!</h2>
                        
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <button class="game-mode-button" id="shop-menu-btn" style="background-color: #f59e0b; flex: 1; margin: 0; font-size: 1.2rem;">üõçÔ∏è Shop</button>
                            <button class="game-mode-button" id="edit-avatar-btn" style="background-color: var(--pink-color); flex: 1; margin: 0; font-size: 1.2rem;">üòé Buddy</button>
                        </div>

                        <button class="game-mode-button" data-mode="letters" style="background-color: var(--primary-color);">
                            <span style="font-size: 2rem; vertical-align: middle; margin-right: 10px;">üÖ∞Ô∏è</span> Find Letters
                        </button>
                        <button class="game-mode-button" data-mode="numbers" style="background-color: var(--correct-color);">
                            <span style="font-size: 2rem; vertical-align: middle; margin-right: 10px;">1Ô∏è‚É£</span> Find Numbers
                        </button>
                        <button class="game-mode-button" data-mode="counting" style="background-color: var(--teal-color);">
                            <span style="font-size: 2rem; vertical-align: middle; margin-right: 10px;">üçé</span> Counting Fun
                        </button>
                        <button class="game-mode-button" data-mode="shapes" style="background-color: var(--orange-color);">
                            <span style="font-size: 2rem; vertical-align: middle; margin-right: 10px;">üî∑</span> Colors & Shapes
                        </button>
                        <button class="game-mode-button" data-mode="letterMatch" style="background-color: var(--purple-color);">
                            <span style="font-size: 2rem; vertical-align: middle; margin-right: 10px;">Aa</span> Letter Matching
                        </button>
                        <button class="game-mode-button" data-mode="inOrderLetters" style="background-color: var(--secondary-color); color: var(--text-color);">
                            <span style="font-size: 2rem; vertical-align: middle; margin-right: 10px;">üöÇ</span> Letters in Order
                        </button>
                        <button class="game-mode-button" data-mode="inOrderNumbers" style="background-color: #ef4444;">
                            <span style="font-size: 2rem; vertical-align: middle; margin-right: 10px;">üöÄ</span> Numbers in Order
                        </button>
                    </div>`;
                    break;
                case 'badges-modal':
                    content = `<div class="modal-content"><span class="close-modal">&times;</span><h2 class="modal-title">Your Awesome Badges</h2><div id="badge-container">${renderBadgesHTML()}</div></div>`;
                    break;
                case 'shop-modal':
                    content = `<div class="modal-content"><span class="close-modal">&times;</span><h2 class="modal-title">Fun Shop</h2><div class="shop-coin-display">üí∞ You have ${state.coins} coins</div><div id="shop-container">${renderShopHTML()}</div></div>`;
                    break;
                case 'avatar-builder-modal':
                    content = `<div class="modal-content"><h2 class="modal-title">Create Your Buddy!</h2><div id="avatar-builder-container">${renderAvatarBuilderHTML()}</div><button id="builder-finish-btn">Done!</button></div>`;
                    break;
                case 'confirm-modal':
                    content = `<div class="modal-content"><p id="confirm-text"></p><div id="confirm-buttons"><button id="confirm-yes" class="confirm-btn">Yes</button><button id="confirm-no" class="confirm-btn">No</button></div></div>`;
                    break;
            }
            el.innerHTML = content;
            addEventListenersForTemplate(templateId);
        }

        function addEventListenersForTemplate(templateId) {
            const containerEl = document.getElementById(templateId);
            if (!containerEl) return;

            switch(templateId) {
                case 'game-screen':
                    const speaker = containerEl.querySelector('#prompt-speaker');
                    if (speaker) {
                        speaker.addEventListener('click', () => {
                            if (state.gameMode === 'counting') {
                                const promptText = el('prompt-text')?.textContent || 'How many?';
                                speak(promptText);
                            } else if (state.gameMode === 'shapes') {
                                speak(`Find the ${state.currentItem}`);
                            } else if (state.gameMode === 'letterMatch') {
                                const promptEl = el('prompt-text');
                                if (promptEl) speak(promptEl.textContent);
                            } else {
                                speak(`Find the ${state.gameMode === 'letters' ? 'letter' : 'number'}, ${state.currentItem}`);
                            }
                        });
                    }
                    break;
case 'menu-modal':
                    // 1. Game Mode Buttons
                    containerEl.querySelectorAll('.game-mode-button[data-mode]').forEach(btn => 
                        btn.addEventListener('click', handleGameModeSelect)
                    );

                    // 2. Edit Avatar Button
                    const editBtn = containerEl.querySelector('#edit-avatar-btn');
                    if (editBtn) {
                        editBtn.addEventListener('click', () => {
                            menuModal.classList.remove('visible');
                            renderTemplate('avatar-builder-modal');
                            const previewArea = document.getElementById('avatar-preview-area');
                            if(previewArea) previewArea.innerHTML = generateAvatarSVG(state.selectedAvatar);
                            avatarBuilderModal.classList.add('visible');
                        });
                    }

                    // 3. NEW: Shop Button Logic
                    const shopBtn = containerEl.querySelector('#shop-menu-btn');
                    if (shopBtn) {
                        shopBtn.addEventListener('click', () => {
                            menuModal.classList.remove('visible');
                            shopModal.classList.add('visible');
                            // Trigger badge if it's their first visit
                            checkAchievements('shop_explorer');
                            // Ensure the shop is rendered freshly
                            const shopContainer = document.getElementById('shop-container');
                            if(shopContainer) shopContainer.innerHTML = renderShopHTML();
                        });
                    }
                    break;
                case 'badges-modal':
                case 'shop-modal':
                    const closeModalButton = containerEl.querySelector('.close-modal');
                    if (closeModalButton) {
                        closeModalButton.addEventListener('click', () => containerEl.classList.remove('visible'));
                    }
                    break;
case 'avatar-builder-modal':
                     // 1. Handle clicking items on the shelf
                     containerEl.querySelectorAll('.builder-option').forEach(opt => opt.addEventListener('click', handleBuilderOptionSelect));
                     
                     // 2. FINISH BUTTON (Checkmark)
                     const finishBtn = containerEl.querySelector('#builder-finish-btn');
                     if(finishBtn) {
                         finishBtn.innerHTML = '‚úÖ'; 
                         finishBtn.addEventListener('click', () => {
                             createConfetti(); 
                             playSound('success');
                             handleBuilderFinish();
                         });
                     }

                     // 3. MAGIC DICE (Instant Preview Logic)
                     const randomBtn = containerEl.querySelector('#btn-randomize');
                     if (randomBtn) {
                         randomBtn.addEventListener('click', () => {
                             playSound('pop');
                             
                             // A. Randomize internal state
                             state.selectedAvatar.head = getRandomItem(state.unlockedAvatarParts.head);
                             state.selectedAvatar.eyes = getRandomItem(state.unlockedAvatarParts.eyes);
                             state.selectedAvatar.mouth = getRandomItem(state.unlockedAvatarParts.mouth);
                             state.selectedAvatar.color = getRandomItem(state.unlockedAvatarParts.color);
                             
                             // B. Update the Big Preview immediately
                             const previewArea = document.getElementById('avatar-preview-area');
                             if(previewArea) previewArea.innerHTML = generateAvatarSVG(state.selectedAvatar);
                             
                             // C. Update the shelf highlights (so he knows what was picked)
                             containerEl.querySelectorAll('.builder-option').forEach(opt => {
                                 opt.classList.remove('selected');
                                 if (opt.dataset.id === state.selectedAvatar[opt.dataset.type]) {
                                     opt.classList.add('selected');
                                     // Optional: Scroll the shelf to show the selected item?
                                     // opt.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                                 }
                             });
                         });
                     }
                    break;
            }
        }

        function switchScreen(screenId) {
            elAll('.screen').forEach(s => s.classList.remove('active'));
            el(screenId).classList.add('active');
        }
let hintTimer = null;

        function startHintTimer() {
            clearTimeout(hintTimer);
            // Wait 8 seconds, then show hint
            hintTimer = setTimeout(() => {
                const buttons = document.querySelectorAll('.option-button');
                buttons.forEach(btn => {
                    // Check if this button holds the correct answer
                    // (Handle complex values like "Color Shape" by checking includes or exact match)
                    if (btn.dataset.value === String(state.currentItem) || 
                        btn.dataset.value.includes(String(state.currentItem))) {
                        btn.classList.add('hint-active');
                        playSound('pop'); // Gentle sound to get attention
                    }
                });
            }, 8000); 
        }
        // --- GAME LOGIC ---
        function getRandomItem(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function generateOptions() {
            const source = state.gameMode === 'letters' ? ALPHABET : NUMBERS;
            state.currentItem = getRandomItem(source);
            const options = new Set([state.currentItem]);
            while(options.size < 4) options.add(getRandomItem(source));
            state.options = Array.from(options);
            shuffleArray(state.options);
        }

        function renderOptions() {
            const grid = el('options-grid');
            if (!grid) return;
            grid.innerHTML = '';
            state.options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-button';
                button.textContent = option;
                button.dataset.value = option;
                button.addEventListener('click', handleChoice);
                grid.appendChild(button);
            });
        }
        
        // --- NEW: Render Shape Options ---
        function renderShapeOptions() {
            const grid = el('options-grid');
            if (!grid) return;
            grid.innerHTML = '';
            // Clear the item display area
            const itemDisplay = el('item-display-area');
            if (itemDisplay) itemDisplay.innerHTML = ''; 

            state.options.forEach(option => {
                const button = document.createElement('button');
                // Note the new 'shape-option' class
                button.className = 'option-button shape-option'; 
                // Set the SVG as the content, colored with the option's color
                button.innerHTML = `<svg viewBox="0 0 100 100" fill="${option.color.hex}" xmlns="http://www.w3.org/2000/svg">
                    ${option.shape.svg}
                </svg>`;
                button.dataset.value = `${option.color.name} ${option.shape.name}`;
                button.addEventListener('click', handleChoice);
                grid.appendChild(button);
            });
        }

        function nextTurn() {
            if (state.gameMode === 'counting') {
                nextCountingTurn();
            } else if (state.gameMode === 'shapes') {
                nextShapeTurn();
            } else if (state.gameMode === 'letterMatch') {
                nextLetterMatchTurn();
            } else {
                // Existing logic for letters/numbers
                generateOptions(); 
                renderOptions();
                const itemType = state.gameMode === 'letters' ? 'letter' : 'number';
                const promptText = el('prompt-text');
                if (promptText) {
                    promptText.textContent = `Find the ${itemType}...`;
                }
                // Clear the item display area in case previous game was 'counting'
                const itemDisplay = el('item-display-area');
                if (itemDisplay) itemDisplay.innerHTML = ''; 
                
                setTimeout(() => speak(`Find the ${itemType}, ${state.currentItem}`), 200);
startHintTimer(); // <--- ADD THIS LINE
        }
        }
let isProcessingClick = false;
function handleChoice(e) {
            // 1. RAPID CLICK PROTECTION
            if (isProcessingClick) return; 
            isProcessingClick = true;
            setTimeout(() => isProcessingClick = false, 500); // Reset after 0.5s

            clearTimeout(hintTimer);

            // Use e.currentTarget to get the button, not e.target which could be the SVG
            const selectedButton = e.currentTarget;
            const selected = selectedButton.dataset.value;

            // Handle non-string currentItem (e.g., from counting)
            const currentTarget = String(state.currentItem);
            
            if (selected === currentTarget) {
                // CORRECT ANSWER
                // Disable all buttons now that the turn is over
                elAll('.option-button').forEach(b => b.disabled = true);
                selectedButton.classList.add('correct-glow');

                // --- VISUAL REINFORCEMENT (Letter Match) ---
                if (state.gameMode === 'letterMatch') {
                    const itemDisplay = document.getElementById('item-display-area');
                    if (itemDisplay) {
                        const answer = state.currentItem;
                        // Figure out what the prompt was (the opposite case)
                        const prompt = answer === answer.toUpperCase() ? answer.toLowerCase() : answer.toUpperCase();
                        
                        // Render: Flexbox for side-by-side, Dark Color for text
                        itemDisplay.innerHTML = `
                            <div style="
                                display: flex; 
                                justify-content: center; 
                                gap: 20px; 
                                font-size: 6rem; 
                                font-family: var(--font-main); 
                                color: var(--text-color); 
                                animation: pop-in 0.5s;
                            ">
                                <span>${prompt}</span>
                                <span>${answer}</span>
                            </div>`;
                    }
                }
                
                createConfetti();
                speak(getRandomItem(CORRECT_PHRASES)); 
                
                state.streak++;
                const basePoints = 5;
                const streakBonus = Math.pow(2, state.streak - 1);
                state.coins += basePoints + streakBonus;
                showPointsPopup(basePoints, streakBonus);

                checkAchievements('first_correct');
                if(state.streak >= 5) checkAchievements('streak_5');
                if(state.streak >= 10) checkAchievements('streak_10');
                if(state.coins >= 50) checkAchievements('coins_50');
                if(state.coins >= 250) checkAchievements('coins_250');
                
                if (state.gameMode === 'letters') {
                    foundLetters.add(state.currentItem);
                    if(foundLetters.size === ALPHABET.length) checkAchievements('all_letters_found');
                } else if (state.gameMode === 'numbers') {
                    foundNumbers.add(state.currentItem);
                    if(foundNumbers.size === NUMBERS.length) checkAchievements('all_numbers_found');
                }

                // Move to next turn after a delay
                setTimeout(() => nextTurn(), 2500);

            } else {
                // INCORRECT ANSWER
                selectedButton.disabled = true; // Disable just this button temporarily
                selectedButton.classList.add('shake-incorrect');
                speak('Oops, try again.');
                state.streak = 0; // Reset streak

                // After the shake, re-enable the button so they can try again
                setTimeout(() => {
                    selectedButton.classList.remove('shake-incorrect');
                    selectedButton.disabled = false; 
                }, 800); 
            }
            updateUI();
            saveProgress();
        }

        // --- NEW COUNTING GAME FUNCTIONS ---
        function nextCountingTurn() {
            const itemToCount = getRandomItem(COUNTING_ITEMS);
            // Generate a correct count between 2 and 10
            const correctCount = Math.floor(Math.random() * 9) + 2; 
            
            state.currentItem = String(correctCount);
            const options = new Set([state.currentItem]);
            
            // Generate different wrong answers
            while(options.size < 4) {
                let wrongOption = Math.floor(Math.random() * 9) + 2;
                options.add(String(wrongOption));
            }
            
            state.options = Array.from(options);
            shuffleArray(state.options);
            
            renderCountingItems(itemToCount, correctCount);
            renderOptions(); // This will render the number buttons
            
const promptText = el('prompt-text');
            if (promptText) {
                // FIXED: Just say "Find the number" instead of "How many apples?"
                promptText.textContent = 'Count the number of items.';
            }
            
            setTimeout(() => {
                const promptEl = el('prompt-text');
                if (promptEl) speak(promptEl.textContent);
            }, 200);
        }

        function renderCountingItems(item, count) {
            const displayArea = el('item-display-area');
            if (!displayArea) return;
            displayArea.innerHTML = ''; // Clear previous items
            
            let itemsHTML = '';
            for (let i = 0; i < count; i++) {
                itemsHTML += `<span class="counting-item">${item}</span>`;
            }
            displayArea.innerHTML = itemsHTML;
        }

        // --- NEW SHAPES GAME FUNCTIONS ---
        function nextShapeTurn() {
            // 1. Pick a correct color and shape
            const correctColor = getRandomItem(COLORS);
            const correctShape = getRandomItem(SHAPES);
            state.currentItem = `${correctColor.name} ${correctShape.name}`;

            const correctOption = { color: correctColor, shape: correctShape };
            const options = [correctOption];

            // 2. Generate 3 unique distractors
            while (options.length < 4) {
                const randColor = getRandomItem(COLORS);
                const randShape = getRandomItem(SHAPES);
                const newOption = { color: randColor, shape: randShape };

                // Ensure it's not the correct answer
                const isCorrect = (newOption.color.name === correctColor.name && newOption.shape.name === correctShape.name);
                // Ensure it's not a duplicate of an existing option
                const isDuplicate = options.some(opt => opt.color.name === newOption.color.name && opt.shape.name === newOption.shape.name);

                if (!isCorrect && !isDuplicate) {
                    options.push(newOption);
                }
            }

            // 3. Shuffle and render
            state.options = options;
            shuffleArray(state.options);
            
            renderShapeOptions(); // Use the new renderer
            
            const promptText = el('prompt-text');
            if (promptText) {
                promptText.textContent = `Find the ${state.currentItem}...`;
            }
            
            setTimeout(() => speak(`Find the ${state.currentItem}`), 200);
        }

        // --- NEW: Letter Matching Game Functions ---
function nextLetterMatchTurn() {
            // 1. Decide to match upper-to-lower or lower-to-upper
            const matchUpper = Math.random() > 0.5;
            const sourceIndex = Math.floor(Math.random() * ALPHABET.length);

            const promptLetter = matchUpper ? ALPHABET[sourceIndex] : ALPHABET_LOWERCASE[sourceIndex];
            const correctLetter = matchUpper ? ALPHABET_LOWERCASE[sourceIndex] : ALPHABET[sourceIndex];
            
            state.currentItem = correctLetter;
            const optionsSource = matchUpper ? ALPHABET_LOWERCASE : ALPHABET;

            // 2. Generate options
            const options = new Set([correctLetter]);
            while(options.size < 4) {
                options.add(getRandomItem(optionsSource));
            }
            
            state.options = Array.from(options);
            shuffleArray(state.options);
            
            // 3. Render Buttons
            renderOptions(); 
            
            // 4. THE FIX: Display the PROMPT letter Big in the middle box!
            const itemDisplay = el('item-display-area');
            if (itemDisplay) {
                // Show the letter big (like a flashcard)
                itemDisplay.innerHTML = `<div style="font-size: 6rem; font-family: var(--font-main); color: var(--text-color);">${promptLetter}</div>`;
            }

            // 5. Set prompt text (for parents)
            const promptText = el('prompt-text');
            if (promptText) {
                promptText.textContent = `Find the match for '${promptLetter}'`;
            }
            
            setTimeout(() => speak(`Find the match for, ${promptLetter}`), 200);
        }


        // --- IN-ORDER GAME MODE LOGIC ---
        function startInOrderGame() {
            const isLetters = state.gameMode === 'inOrderLetters';
            state.inOrderSequence = isLetters ? ALPHABET : NUMBERS;
            state.inOrderDisplaySequence = [...state.inOrderSequence];
            shuffleArray(state.inOrderDisplaySequence);
            state.inOrderIndex = 0;
            const promptEl = el('in-order-prompt');
            if (promptEl) {
                promptEl.textContent = isLetters ? 'Find the letters in order!' : 'Find the numbers in order!';
            }
            
            // Adjust grid for numbers vs letters
            const grid = el('in-order-grid');
            if (grid) {
                if(isLetters) {
                    grid.style.gridTemplateColumns = 'repeat(5, 1fr)';
                } else {
                    // More compact grid for 0-20 numbers
                    grid.style.gridTemplateColumns = 'repeat(7, 1fr)';
                }
            }

            renderInOrderGrid();
            renderSequenceDisplay();
            // ADD THIS LINE: Auto-scroll the ticker tape to the right
                const tape = document.getElementById('sequence-display-container');
                if(tape) tape.scrollTo({ left: tape.scrollWidth, behavior: 'smooth' });
            speak(`Let's find the ${isLetters ? 'letters' : 'numbers'} in order. First, find ${state.inOrderSequence[0]}`);
        }

        function renderInOrderGrid() {
            const grid = el('in-order-grid');
            if(!grid) return;
            grid.innerHTML = '';
            state.inOrderDisplaySequence.forEach(item => {
                const button = document.createElement('button');
                button.className = 'in-order-item';
                button.textContent = item;
                button.dataset.value = item;
                if (state.inOrderSequence.indexOf(item) < state.inOrderIndex) button.classList.add('completed');
                button.addEventListener('click', handleInOrderChoice);
                grid.appendChild(button);
            });
        }
        
        function handleInOrderChoice(e) {
            const selected = e.target.dataset.value;
            const nextItemInSequence = state.inOrderSequence[state.inOrderIndex];
            
            if (selected === nextItemInSequence) {
                state.inOrderIndex++; 
                state.coins += 2;
                if(state.coins >= 50) checkAchievements('coins_50');
                if(state.coins >= 250) checkAchievements('coins_250');
                updateUI(); 
                saveProgress();
                if (state.inOrderIndex >= state.inOrderSequence.length) {
                    speak('Wow, you did it!'); 
                    createConfetti();
                    const promptEl = el('in-order-prompt');
                    if (promptEl) promptEl.textContent = 'You are amazing!';
                    if(state.gameMode === 'inOrderLetters') checkAchievements('in_order_letters');
                    if(state.gameMode === 'inOrderNumbers') checkAchievements('in_order_numbers');
                    setTimeout(() => menuModal.classList.add('visible'), 2000);
                } else {
                    speak(`Great! Now find ${state.inOrderSequence[state.inOrderIndex]}`);
                }
                renderInOrderGrid();
                renderSequenceDisplay();
                const tape = document.getElementById('sequence-display-container');
                if(tape) tape.scrollTo({ left: tape.scrollWidth, behavior: 'smooth' });
            } else {
                speak(`Oops, try again.`);
                const button = e.target;
                const grid = el('in-order-grid');
                if (grid) grid.style.pointerEvents = 'none';
                button.classList.add('shake-incorrect');
                button.style.backgroundColor = 'var(--incorrect-color)'; 
                button.style.color = 'white';
                setTimeout(() => {
                    button.classList.remove('shake-incorrect');
                    button.style.backgroundColor = ''; 
                    button.style.color = '';
                    if (grid) grid.style.pointerEvents = 'auto';
                }, 800);
            }
        }

        function renderSequenceDisplay() {
            const container = el('sequence-display-container');
            if (!container) return;
            container.innerHTML = '';
            state.inOrderSequence.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'sequence-item';
                div.textContent = item;
                if (index < state.inOrderIndex) {
                    div.classList.add('filled');
                }
                container.appendChild(div);
            });
        }

        // --- ACHIEVEMENTS & BADGES ---
        function checkAchievements(badgeKey) {
            if (!state.unlockedBadges.includes(badgeKey)) {
                state.unlockedBadges.push(badgeKey);
                showAchievementPopup(BADGES[badgeKey], badgeKey);
                if (SHOP_DATA.stickers[badgeKey] && !state.unlockedStickers.includes(badgeKey)) {
                    state.unlockedStickers.push(badgeKey);
                }
                saveProgress();
                updateUI();
            }
        }
        
        function renderBadgesHTML() {
            let html = '';
            for (const key in BADGES) {
                const badge = BADGES[key];
                const isUnlocked = state.unlockedBadges.includes(key);
                html += `<div><div class="badge ${isUnlocked ? 'unlocked' : ''}" title="${badge.description}">${badge.icon}</div><div class="badge-tooltip">${badge.title}</div></div>`;
            }
            return html;
        }

        function showAchievementPopup(badge, badgeKey) {
            const popup = document.createElement('div');
            popup.style.cssText = `position: absolute; top: 80px; left: 50%; transform: translateX(-50%); background: linear-gradient(45deg, var(--secondary-color), #fde047); color: var(--text-color); padding: 20px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); font-family: var(--font-main); z-index: 101; text-align: center; animation: slide-in-out 3s ease;`;
            popup.innerHTML = `<div>üèÜ New Badge! üèÜ</div><div style="font-size: 1.2rem;">${badge.title}</div>`;
            gameContainer.appendChild(popup);
            speak(`New Badge! ${badge.title}`);
            if(SHOP_DATA.stickers[badgeKey]) speak('You unlocked a new sticker!');
            setTimeout(() => popup.remove(), 3000);
        }

        function showPointsPopup(base, bonus) {
            const popup = document.createElement('div');
            popup.innerHTML = `+${base}üí∞ +${bonus}üî•`;
            popup.style.cssText = `
                position: absolute; top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                font-family: var(--font-main); font-size: 2.5rem;
                color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
                padding: 10px 20px; background: linear-gradient(45deg, var(--correct-color), #86efac);
                border-radius: 20px; border: 3px solid white;
                z-index: 101; pointer-events: none;
                animation: fade-up-out 1.5s ease-out forwards;
            `;
            gameContainer.appendChild(popup);
            setTimeout(() => popup.remove(), 1450);
        }

function renderAvatarBuilderHTML() {
            let html = `
                <div id="avatar-preview-area"></div>
                
                <button id="btn-randomize" title="Randomize">üé≤</button>

                <div id="builder-scroll-area">
                    <div class="builder-controls">`;
            
            const categories = {
                head: 'Head Shape',
                eyes: 'Eyes',
                mouth: 'Mouth',
                color: 'Color'
            };

            for (const category in categories) {
                html += `<div class="builder-category"><div class="builder-category-title">${categories[category]}</div><div class="builder-options">`;
                const unlockedParts = state.unlockedAvatarParts[category];
                unlockedParts.forEach(partId => {
                    const isSelected = state.selectedAvatar[category] === partId;
                    let content = '';
                    if (category === 'color') {
                        content = ''; 
                    } else {
                        content = `<svg viewBox="0 0 100 100" fill="none" stroke="#000000">${AVATAR_PARTS[category][partId]}</svg>`;
                    }
                    
                    html += `<div class="builder-option ${category === 'color' ? 'color-option' : ''} ${isSelected ? 'selected' : ''}" 
                                  style="${category === 'color' ? 'background-color:'+partId : ''}" 
                                  data-type="${category}" 
                                  data-id="${partId}">
                                ${content}
                            </div>`;
                });
                html += `</div></div>`;
            }
            html += `</div></div>`;
            return html;
        }

function handleBuilderOptionSelect(e) {
            const target = e.currentTarget;
            const type = target.dataset.type;
            const id = target.dataset.id;
            
            // 1. Update State
            state.selectedAvatar[type] = id;

            // 2. Visually update the buttons without re-rendering the whole list
            // Find the container for this specific category (eyes, mouth, etc)
            const categoryContainer = target.parentElement;
            
            // Remove 'selected' class from the old option in this category
            const oldSelected = categoryContainer.querySelector('.builder-option.selected');
            if (oldSelected) oldSelected.classList.remove('selected');
            
            // Add 'selected' class to the clicked option
            target.classList.add('selected');

            // 3. Update the Preview Area only
            const previewArea = document.getElementById('avatar-preview-area');
            if(previewArea) previewArea.innerHTML = generateAvatarSVG(state.selectedAvatar);
        }

        function handleBuilderFinish() {
            if (!state.avatarName || state.avatarName.length === 0) {
                state.avatarName = 'BUD'; // Default name
            }
            state.avatarChosen = true;
            applyAvatar();
            saveProgress();
            avatarBuilderModal.classList.remove('visible');
            menuModal.classList.add('visible');
        }

        function generateAvatarSVG(avatarData) {
            const { head, eyes, mouth, color } = avatarData;
            return `
                <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <g fill="${color}" stroke="${color === '#ffffff' ? '#000000' : 'none'}">
                        ${AVATAR_PARTS.head[head]}
                    </g>
                    <g fill="black" stroke="black">
                        ${AVATAR_PARTS.eyes[eyes]}
                    </g>
                    <g fill="none" stroke="black">
                        ${AVATAR_PARTS.mouth[mouth]}
                    </g>
                </svg>
            `;
        }
        
        function applyAvatar() {
            avatarDisplayEl.style.backgroundColor = 'transparent';
            avatarDisplayEl.innerHTML = generateAvatarSVG(state.selectedAvatar);
            const accessory = SHOP_DATA.accessories.find(a => a.id === state.selectedAccessory);
            if (accessory && accessory.id !== 'none') {
                 const accessoryEl = document.createElement('span');
                 accessoryEl.className = 'avatar-accessory';
                 accessoryEl.textContent = accessory.value;
                 avatarDisplayEl.appendChild(accessoryEl);
            }
        }
        
        // --- SHOP LOGIC ---
function renderShopHTML() {
            const categories = {
                avatarParts: { title: "Body Parts", items: SHOP_DATA.avatarParts },
                accessories: { title: "Hats & Glasses", items: SHOP_DATA.accessories },
                backgrounds: { title: "World Themes", items: SHOP_DATA.backgrounds },
                cursors: { title: "Magic Fingers", items: SHOP_DATA.cursors },
            };

            let html = '';
            
            for (const key in categories) {
                const category = categories[key];
                if (!category.items || category.items.length === 0) continue;

                html += `<div class="shop-category">
                    <div class="shop-category-title">${category.title}</div>
                    <div class="shop-shelf">`;

                category.items.forEach(item => {
                    // 1. Determine Ownership & Selection
                    let isUnlocked = false;
                    let isSelected = false;

                    switch(key) {
                        case 'avatarParts': 
                            isUnlocked = state.unlockedAvatarParts[item.type]?.includes(item.value); 
                            isSelected = state.selectedAvatar[item.type] === item.value;
                            break;
                        case 'accessories': 
                            isUnlocked = state.unlockedAccessories.includes(item.id); 
                            isSelected = state.selectedAccessory === item.id; 
                            break;
                        case 'backgrounds': 
                            isUnlocked = state.unlockedItems.backgrounds.includes(item.id); 
                            isSelected = state.selectedItems.background === item.id; 
                            break;
                        case 'cursors': 
                            isUnlocked = state.unlockedItems.cursors.includes(item.id); 
                            isSelected = state.selectedItems.cursor === item.id; 
                            break;
                    }

                    // 2. Determine Content (The Visuals)
                    let content = '';
                    let customClass = '';
                    let customStyle = '';

                    // HANDLE COLORS (The visual fix)
                    if (item.type === 'color') {
                        customClass = 'color-item';
                        customStyle = `background-color: ${item.value}; border: 4px solid white; box-shadow: 0 4px 6px rgba(0,0,0,0.1);`;
                    } 
                    // HANDLE BACKGROUNDS
                    else if (key === 'backgrounds') {
                        if(item.id === 'default') content = '<span style="font-size:2rem;">‚¨ú</span>';
                        else customStyle = `background: ${item.value};`;
                    }
                    // HANDLE CURSORS
                    else if (key === 'cursors') {
                         if(item.id === 'default') content = '<span style="font-size:3rem;">üëÜ</span>';
                         else content = `<span style="font-size:3rem;">${item.value}</span>`;
                    }
                    // HANDLE SVGS (Avatar Parts)
                    else if (item.type && AVATAR_PARTS[item.type]) {
                         content = `<svg viewBox="0 0 100 100" fill="none" stroke="black">
                                ${AVATAR_PARTS[item.type][item.value]}
                            </svg>`;
                    }
                    // HANDLE EMOJIS (Accessories)
                    else {
                        content = `<span style="font-size:3rem;">${item.value || item.name}</span>`;
                    }

                    // 3. Determine The Tag (Price vs Owned vs Equipped)
                    let tagHTML = '';
                    if (isSelected) tagHTML = `<div class="shop-tag tag-equipped">On!</div>`;
                    else if (isUnlocked) tagHTML = `<div class="shop-tag tag-owned">Owned</div>`;
                    else {
                        const canAfford = state.coins >= item.cost;
                        const priceClass = canAfford ? 'can-afford' : 'cannot-afford';
                        tagHTML = `<div class="shop-tag tag-price ${priceClass}">üí∞ ${item.cost}</div>`;
                    }

                    // 4. Render
                    html += `<div class="shop-item ${customClass} ${isSelected ? 'selected' : ''}" 
                                  style="${customStyle}"
onclick="window.handleShopItemClick(event, '${key}', '${item.id}')">                                 ${content}
                                 ${tagHTML}
                             </div>`;
                });
                html += `</div></div>`;
            }
            return html;
        }

window.handleShopItemClick = (e, category, itemId) => {
            // 1. RAPID CLICK PROTECTION
            if (isProcessingClick) return; 
            isProcessingClick = true;
            setTimeout(() => isProcessingClick = false, 500);

            if (category === 'stickers') return;
            const itemData = SHOP_DATA[category].find(i => i.id === itemId);
            if (!itemData) return;

            // Check if owned
            let isUnlocked;
            if (category === 'avatarParts') isUnlocked = state.unlockedAvatarParts[itemData.type].includes(itemData.value);
            else if (category === 'accessories') isUnlocked = state.unlockedAccessories.includes(itemId);
            else if (category === 'backgrounds') isUnlocked = state.unlockedItems.backgrounds.includes(itemId);
            else if (category === 'cursors') isUnlocked = state.unlockedItems.cursors.includes(itemId);

            // LOGIC:
            if (isUnlocked) {
                // ALREADY OWNED -> JUST EQUIP
                equipItem(category, itemId, itemData);
                playSound('pop');
            } else {
                // NOT OWNED -> TRY TO BUY
                if (state.coins >= itemData.cost) {
                    // SUCCESS
                    state.coins -= itemData.cost;
                    
                    if (category === 'avatarParts') state.unlockedAvatarParts[itemData.type].push(itemData.value);
                    else if (category === 'accessories') state.unlockedAccessories.push(itemId);
                    else if (category === 'backgrounds') state.unlockedItems.backgrounds.push(itemId);
                    else if (category === 'cursors') state.unlockedItems.cursors.push(itemId);
                    
                    checkAchievements('first_purchase');
                    playSound('success');
                    speak('Cool!');
                    
                    // Auto-Equip on buy
                    equipItem(category, itemId, itemData);
                } else {
                    // FAIL - ANIMATION
                    playSound('error');
                    speak('Need more coins');
                    
                    const clickedItem = e.currentTarget;
                    if(clickedItem) {
                        clickedItem.classList.add('shake-no-money');
                        setTimeout(() => clickedItem.classList.remove('shake-no-money'), 500);
                    }
                }
            }
            // Save and Force Re-render to show "Equipped" status
            saveProgress();
            const shopContainer = document.getElementById('shop-container');
            if(shopContainer) shopContainer.innerHTML = renderShopHTML();
            updateUI(); 
        };
        
        // Helper to separate Equip logic
        function equipItem(category, itemId, itemData) {
            if (category === 'accessories') state.selectedAccessory = itemId;
            else if (category === 'backgrounds') state.selectedItems.background = itemId;
            else if (category === 'cursors') state.selectedItems.cursor = itemId;
            else if (category === 'avatarParts') state.selectedAvatar[itemData.type] = itemData.value;

            if (category.startsWith('avatar') || category === 'accessories') applyAvatar();
            else applyShopItems();
        }

        function applyShopItems() {
            const bgItem = SHOP_DATA.backgrounds.find(b => b.id === state.selectedItems.background);
            if (bgItem) gameContainer.style.background = bgItem.value;
            
            const cursorItem = SHOP_DATA.cursors.find(c => c.id === state.selectedItems.cursor);
            if(cursorItem) {
                if(cursorItem.id === 'default') gameContainer.style.cursor = 'auto';
                else gameContainer.style.cursor = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='40' height='48' viewport='0 0 100 100' style='fill:black;font-size:24px;'><text y='50%'>${cursorItem.value}</text></svg>") 16 0, auto`;
            }
        }
        
        function showConfirm(text, onConfirm) {
            const confirmText = el('confirm-text');
            if(!confirmText) return;
            confirmText.textContent = text;
            confirmModal.classList.add('visible');

            const yesBtn = el('confirm-yes');
            const noBtn = el('confirm-no');

            const confirmHandler = () => {
                onConfirm();
                confirmModal.classList.remove('visible');
                cleanup();
            };
            const cancelHandler = () => {
                confirmModal.classList.remove('visible');
                cleanup();
            };
            
            const cleanup = () => {
                yesBtn.removeEventListener('click', confirmHandler);
                noBtn.removeEventListener('click', cancelHandler);
            }
            
            yesBtn.addEventListener('click', confirmHandler);
            noBtn.addEventListener('click', cancelHandler);
        }

        // Add keyframes for the popup
        const styleSheet = document.createElement("style");
        styleSheet.type = "text/css";
        styleSheet.innerText = `
            @keyframes slide-in-out { 0% { top: -100px; opacity: 0; } 20% { top: 80px; opacity: 1; } 80% { top: 80px; opacity: 1; } 100% { top: -100px; opacity: 0; } }
            @keyframes fade-up-out { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -150%) scale(1.2); } }
        `;
        document.head.appendChild(styleSheet);

// --- ARCADE SOUND SYNTHESIZER ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            
            if (type === 'success') {
                // High pitch "Ding!"
                osc.type = 'sine';
                osc.frequency.setValueAtTime(500, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            } else if (type === 'error') {
                // Low pitch "Buh-buh"
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'pop') {
                // Quick "Pop" for buttons
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }
        // --- EVENT LISTENERS ---
        function handleGameModeSelect(e) {
            state.gameMode = e.target.dataset.mode;
            menuModal.classList.remove('visible');
            if (state.gameMode.startsWith('inOrder')) {
                switchScreen('in-order-screen');
                startInOrderGame();
            } else {
                switchScreen('game-screen');
                nextTurn();
            }
        }

        // Navigation
        navHomeBtn.addEventListener('click', () => menuModal.classList.add('visible'));
        navBadgesBtn.addEventListener('click', () => badgesModal.classList.add('visible'));
        navShopBtn.addEventListener('click', () => {
            checkAchievements('shop_explorer');
            shopModal.classList.add('visible');
        });
        // --- NEW: SKIP BUTTON LOGIC ---
        const navSkipBtn = document.getElementById('nav-skip');
        if (navSkipBtn) {
            navSkipBtn.addEventListener('click', () => {
                playSound('pop'); // Sound effect
                
                // 1. Handle "In Order" Games (Auto-complete the stuck letter)
                if (state.gameMode.startsWith('inOrder')) {
                    state.inOrderIndex++; // Move to next
                    
                    // Check if finished
                    if (state.inOrderIndex >= state.inOrderSequence.length) {
                         speak('All done!');
                         createConfetti();
                         setTimeout(() => menuModal.classList.add('visible'), 2000);
                    } else {
                        // Move to next item
                        speak(`Okay, let's find ${state.inOrderSequence[state.inOrderIndex]}`);
                        renderInOrderGrid();
                        renderSequenceDisplay();
                        // Scroll tape
                        const tape = document.getElementById('sequence-display-container');
                        if(tape) tape.scrollTo({ left: tape.scrollWidth, behavior: 'smooth' });
                    }
                } 
                // 2. Handle Standard Games (New Random Item)
                else {
                    // Visual feedback (shake the old options away)
                    const grid = document.getElementById('options-grid');
                    if(grid) {
                        grid.style.opacity = '0';
                        setTimeout(() => grid.style.opacity = '1', 200);
                    }
                    speak('Skipping!');
                    nextTurn(); // Generate new question
                }
            });
        }
        // --- INITIALIZATION ---
        function init() {
            // Set up the static structure of the game screens once.
            renderTemplate('game-screen');
            renderTemplate('in-order-screen');

            loadProgress();
            resizeCanvas();
            animateParticles();

            // Start on menu screen or avatar selection if first time
            switchScreen('game-screen');
            
            if (!state.avatarChosen) {
                avatarBuilderModal.classList.add('visible');
            } else {
                menuModal.classList.add('visible');
            }
        }

        init();
    });
    
    </script>
</body>
</html>